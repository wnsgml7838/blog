---
layout: post
title: "도커 개요"
date: 2024-12-30
categories: [학습]
tags: [Docker, Container, Virtualization, Kubernetes]
author: 김준희
---

# 1. 도커 개요

## 가상화 개념과 컨테이너

### 가상화란 무엇일까?

- 전통적으로 하드웨어에 종속된 리소스를 사용해 유용한 IT 서비스를 만드는 기술
- 가상화를 상요하면 물리적 머신의 기능을 여러 사용자 또는 환경에 배포해 물리적 머신을 최대한 활용
- 서버를 더 효율적으로 사용해 구매, 셋업, 냉각, 유지관리를 관련도 비용 감소

### 하이퍼바이저의 정의와 가상화 원리

**하이퍼바이저란?**

- 소프트웨어가 물리 리소를 필요로 하는 가상 환경으로부터 물리 리소스를 분리
- 호스트 컴퓨터 1대에서 운영체제 다수를 동시에 실행하는 논리적 플랫폼
    - 의존성 관리가 유용함 → 백업 + 유지관리 편리

하이퍼바이저는 노트북 등의 운영 체제에 배포하거나 서버 등의 하드웨어에 직접 설치

하이퍼바이저가 물리 리소르를 분할하여 가상 환경에서 적용 

### 하이퍼바이저의 종류

**Native - type 1** → 기업, 데이터센터에서 많이 사용하는 방식

- 해당 하드웨어/베어메탈에 직접 설치 → 저수준에서 통신이 가능
- 게스트 운영체제는 두 번째 수준으로 실행
- 하드웨어와 하이퍼바이저가 바로 통신
- 제품 : Xen, KVM(리눅스에서 open stack 운영시 많이 사용), ESXI(VM ware 제품) 등

**Hosted - type 2** → 개인 사용자

- 일반 프로그램처럼 호스트 운영체제에서 실행 (Nox, Blue stack 등..)
- 게스트 운영체제는 세번째 수준으로 실행
- 하드웨어 → Host OS → 하이퍼바이저 : type 1에 비해서 성능이 떨어짐
- 제품 : Virtualbox, Vmware, Parrallels 등


### 컨테이너

- 컨테이너는 가상환경을 사용해 각 마이크로 서비스를 격리하는 기술
- 컨테이너는 가상머신처럼 하드웨어를 전부 구현하지 않기 때문에 매우 빠른 실행 가능
- OS와 하이퍼바이저, VM을 추상화 하는 추상화 계층이 필요했음 → 오버헤드 발생
    - 리소스를 더 효율적으로 사용하고
    - VM의 백업관 복원, 확장을 개선하고 싶다는 요구사항들이 있었음

→ 컨테이너 방식이 나오게됨 (현재는 같이 많이 사용)

- Container Runtime이라는 것을 OS + 하이퍼바이저를 대체하고있음
    - 컨테이너 안에 프로세스를 가둠(격리)으로써 접근 제한을 줄 수 있음 → 훨씬 더 가벼운 환경

### VM과 컨테이너의 실행 시 CPU 사용량 비교

PageRank 워크로드 실행 결과

- 웹페이지들의 중요도를 수치로 평가하는 알고리즘
    - 수백만~수십억 개의 노드와 링크로 구성된 대규모 그래프에서 위와 같은 연산을 반복 수행
    - 행렬 곱셈, 벡터 연산 등  대량의 수치 계산과 반복적인 갱신이 필요하므로, 컴퓨팅 자원을 많이 소모

**결론** : 

- 컨테이너 환경을 VM에 비해 CPU를 더 효율적으로 사용, 대기 상태가 거의 없어서 리소스 낭비가 적음 → 작업 완료 시간이 빠름
- CM 환경은 인스턴스가 많아질수록 CPU 대기 시간이 급격하게 늘어나고, 전체 작업 시간이 길어짐 → 가상화 오버헤드와 리소스 경합 때문
- ex) 컨테이너 에서 App이 12개라면, VM에서는 App 12개, VM 12개, OS도 12개,,

컨테이너와VM, 베어메탈 벤치마크 결과

- 컨테이너는 베어메탈과 거의 동일한 성능을 제공하고, VM(KVM)은 모든 항목에서 오버헤드로 인해 성능이 떨어짐

### 컨테이너를 격리하는 기술

리눅스 네임 스페이스 : Limit What you can see 

- 각 프로세스가 파일 시스템 마운트, 네트워크, 유저(uid), 호스트네임(uts) 등에 대해 시스템에 독립 뷰를 제공

cgroup(컨트롤 그룹) : Limit How much you can use

- 프로세스 그룹이 사용할 수 있는 시스템 자원(메모리, CPU, I/O, 네트워크 등)의 "양"을 제한하거나 모니터링
- cgroup은 자원의 '할당/제한/계량'을 담당하고, 네임스페이스는 '격리'를 담당
- /cpu_mem_cg는 **systemd(리눅스 init 프로세스)[를 더 많이 사용하는 추세]**와 cgroupfs(리눅스 커널)와 같아 "cgroup 계층"의 최상위 관리 주체를 나타냄
- cg와 cg2는 각 컨테이너에 할당된 리소스 그룹

### 도커

- 컨테이너를 직접 사용하기엔 어려움 → 컨테이너 기술을 지원하는 프로젝트 중 하나
- 컨테이너 기술이 이전에도 있었으니 도커로 인해 많이 알려줌 → 컨테이너 기술의 사실상 표준 도커 = 컨테이너
- 애플리케이션에 국한 되지 않고 의존성 및 파일 시스템까지 패키징하여 빌드, 배포, 실행을 단순화
- 리눅스의 네임 스페이스와 cgroups와 같은 커널 기능을 사용하여 가상화

### 도커 아키텍처

**도커 CLI  → 클라리언트 측**

- 사용자가 도커와 상호 작용하기 위한 명령줄 도구
- 사용자는 도커 CLI를 통해 이미지를 빌드, 컨테이너를 생성, 관리
- 사용자가 도커 명령어를 입력하면 도커 데몬에 명령을 전달
- 보통 RestAPI를 사용하여 서버측에 넘겨줌

**도커 데몬 Doker Daemon → 서버 측**

- 도커의 핵심 서비스로 컨테이너의 생성, 실행, 관리 등의 작업을 수행
- 데몬은 컨테이너 실행에 필요한 리소스를 관리하고 도커 API를 통해 클라이언트 요청에 응답
- 네트워크 관리 , 볼륨 등의 인터페이스 역할을 함

**Containerd → 서버 측**

- 실제로 컨테이너 실행은 Containerd에서 진행, 중간 관리자
- 도커 데몬에서 사용하는 핵심 컨테이너 런타임
- 1.11 버전 이후로 컨테이너 런타임을 분리하여 containerd를 사용
- containerd는 컨테이너의 생명주기 관리, 이미지 관리, 네트워킹, 스토리지 등과 관련된 기능을 담당

**Runc → 서버 측**

- 컨테이너를 쪼개고 나눔
- 컨테이너를 실행하는 데 사용되는 도구
- containerd 자체는 컨테이너의 라이프사이클(생성, 시작, 중지, 삭제 등)과 이미지 관리, 네트워크, 스토리지 등 고수준 기능을 담당하며, OCI Spec에 따라 실제로 컨테이너를 실행하는 저수준 런타임인 runc를 호출
- OCI spec은 컨테이너의 실행 환경, 설정 파일(config.json) 등 런타임의 동작 방식을 강의

### 컨테이너 레지스트리에서 필요한 이미지를 다운로드

- 컨테이너 : 이미지를 격리하여 독립된 공간에서 실행한 가상 환경
- 이미지 : 필요한 프로그램과 라이브러리, 소스를 설치한 뒤 만든 하나의 파일
- 레지스트리 : 사용자가 사용할 수 있도록 데이터베이스를 통해 Image를 제공해주고 있음
- 누구나 이미지를 만들어 푸시할 수 있으며 푸시된 이미지는 다른 사람들에게 공유 가능

### 도커의 한계

- 서비스가 커지면 커질 수록 관리해야 하는 컨테이너의 양이 급격히 증가
- 도커를 사용하여 관리를 한다 하더라도 쉽지 않은 상태

### 쿠버네티스

- 다수의 도커 컨테이너를 자동으로 운영하기 위한 오케스트레이션 도구
- 많은 시스템을 통합, 컨테이너를 다루기 위한 API를 제공